
 /*
  *    ==== DO NOT EDIT THIS FILE ====
  */

const char terrain_vert[]="#version 300 es\n"
"precision mediump float;\n"
"\n"
"//attribute vec3 vert_pos;\n"
"//attribute vec3 vert_norm;\n"
"layout(location = 0) in vec3 vert_pos;\n"
"layout(location = 1) in vec3 vert_norm;\n"
"\n"
"uniform mat4 u_proj_mat;\n"
"uniform mat4 u_mod_mat;\n"
"uniform mat3 u_norm_mat;\n"
"uniform vec4 u_color;\n"
"\n"
"uniform bool u_swap_norm;\n"
"\n"
"uniform float u_water_height;\n"
"\n"
"//uniform float u_tex0_scale;\n"
"\n"
"out vec4 v_color;\n"
"out vec2 v_tex_coord;   // interpolated per vertex norm image coords\n"
"out vec3 v_coords3;     // interpolated fragment 3d coords\n"
"out float v_depth;\n"
"\n"
"out vec3 T;\n"
"out vec3 B;\n"
"out vec3 N;\n"
"\n"
"out vec4 v_texmap;\n"
"\n"
"\n"
"uniform bool u_animate;\n"
"uniform float u_time;\n"
"\n"
"\n"
"void main() {\n"
"float h_offset = 0.0;\n"
"float period = 3.0;\n"
"float sinmul = 0.25;\n"
"vec3 newnorm = vert_norm;\n"
"if (u_animate) {\n"
"h_offset = sin((u_time+vert_pos.y)/period)*sinmul;\n"
"newnorm = normalize(vec3(-cos((u_time+vert_pos.y)/period)*sinmul/period, 0.0, 1.0));\n"
"}\n"
"\n"
"\n"
"////////////////////////////\n"
"// vertex and normal translations\n"
"\n"
"// pass 3d coords to fragment shader\n"
"vec4 coords3 = u_mod_mat * vec4(vert_pos.xy, vert_pos.z + h_offset, 1.0);\n"
"v_coords3 = coords3.xyz / coords3.w;\n"
"\n"
"// translate vertex for rasterization\n"
"vec4 pos = u_proj_mat * coords3;\n"
"\n"
"\n"
"\n"
"\n"
"////////////////////////////\n"
"// set gl_Position\n"
"\n"
"// set depth to be logrithmic\n"
"//gl_Position.z = 1.0/gl_Position.z;\n"
"//gl_Position = vec4(pos.xy, log2(pos.z), pos.w);\n"
"gl_Position = pos;\n"
"\n"
"\n"
"\n"
"\n"
"////////////////////////////\n"
"// calculate TBN matrix\n"
"\n"
"// set normal\n"
"// rotate normal according to model matrix\n"
"N = normalize(u_norm_mat * newnorm);\n"
"\n"
"//N.z = u_swap_norm ? -N.z : N.z;\n"
"N = u_swap_norm ? -N : N;\n"
"\n"
"// select temporary fake tangent\n"
"// avoid colinearity\n"
"T = vec3(1.0, 0.0, 0.0);\n"
"if (abs(N.x) > 0.999)\n"
"T = vec3(0.0, 1.0, 0.0);\n"
"\n"
"// set bitangent vector\n"
"B = normalize(cross(N, T));\n"
"\n"
"// set real tangent\n"
"T = normalize(cross(B, N));\n"
"\n"
"\n"
"\n"
"\n"
"////////////////////////////\n"
"// calculate normal coords and per-vertex color\n"
"\n"
"v_tex_coord = v_coords3.xy;// / u_tex0_scale;\n"
"v_color = u_color;\n"
"//v_depth = pos.z/pos.w;\n"
"v_depth = pos.z;\n"
"\n"
"\n"
"////////////////////////////\n"
"// calculate texture map\n"
"\n"
"float wiggle = sin((v_tex_coord.x + v_tex_coord.y)/10.0)*3.0;\n"
"\n"
"v_texmap = vec4(0.0);\n"
"\n"
"//if (v_coords3.z < -25.0 + wiggle)\n"
"if (v_coords3.z < u_water_height -5.0 + wiggle)\n"
"if (N.z > 0.8)\n"
"v_texmap[2] = 1.0;\n"
"else\n"
"v_texmap[3] = 1.0;\n"
"else {\n"
"if (N.z > 0.6 + wiggle/100.0)\n"
"//if (v_coords3.z < -15.0 && N.z > 0.7 || v_coords3.z < -21.0)\n"
"if (v_coords3.z < u_water_height + 5.0 + wiggle) //&& N.z > 0.65)\n"
"v_texmap[2] = 1.0;\n"
"else\n"
"v_texmap[0] = 1.0;\n"
"else\n"
"v_texmap[1] = 1.0;\n"
"}\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
;
