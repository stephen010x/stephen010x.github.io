
 /*
  *    ==== DO NOT EDIT THIS FILE ====
  */

const char underwater_frag[]="#version 300 es\n"
"precision mediump float;\n"
"\n"
"uniform vec3 u_light_norm;\n"
"uniform float u_light_amb;\n"
"uniform float u_light_bright;\n"
"uniform float u_light_spec_bright;\n"
"uniform float u_light_spec_pow;\n"
"uniform vec4 u_light_diff_color;\n"
"uniform vec4 u_light_amb_color;\n"
"uniform vec3 u_cam_pos;\n"
"\n"
"uniform bool u_enable_vfog;\n"
"uniform float u_tex_scale;\n"
"uniform float u_tex_strength;\n"
"uniform sampler2D u_norm0;\n"
"uniform sampler2D u_depth0;\n"
"\n"
"uniform float u_swidth;\n"
"uniform float u_sheight;\n"
"uniform mat4 u_dithermat;\n"
"\n"
"uniform vec4 u_fog_color;\n"
"\n"
"uniform int u_mode;\n"
"\n"
"in vec4 v_color;\n"
"in vec2 v_tex_coord;  // interpolated per vertex norm image coords\n"
"in vec3 v_coords3;     // interpolated fragment 3d coords\n"
"in float v_depth;\n"
"\n"
"in vec3 T;\n"
"in vec3 B;\n"
"in vec3 N;\n"
"\n"
"\n"
"vec3 color_to_norm(vec4 color);\n"
"vec4 norm_to_color(vec3 norm);\n"
"float monochrome(vec4 color);\n"
"float monochrome(vec3 color);\n"
"\n"
"//vec4 encode_float_to_color(float value);\n"
"//float decode_color_to_float(vec4 color);\n"
"\n"
"//float round(float n);\n"
"//vec2 round(vec2 n);\n"
"//vec3 round(vec3 n);\n"
"//vec2 vfloor(vec2 n);\n"
"\n"
"out vec4 o_color;\n"
"\n"
"\n"
"\n"
"void main() {\n"
"//o_color = vec4(0.0, 1.0, 0.0, 1.0);\n"
"//return;\n"
"\n"
"if (u_mode == 2) {\n"
"o_color = u_fog_color;\n"
"return;\n"
"}\n"
"\n"
"////////////////////////////\n"
"// translate normal vector to model space\n"
"\n"
"/*mat3 TBN = mat3(normalize(T), normalize(B), normalize(N));\n"
"vec4 norm_color = texture(u_norm0, v_tex_coord);\n"
"vec4 tex_color = vec4(1.0);\n"
"vec3 prenorm = color_to_norm(norm_color);\n"
"vec3 norm = normalize(TBN * normalize(vec3(prenorm.xy, prenorm.z / u_tex_strength)));\n"
"*/\n"
"\n"
"\n"
"////////////////////////////\n"
"// calculate depth difference\n"
"\n"
"vec2 screen_to_coord = vec2(gl_FragCoord.x / u_swidth, gl_FragCoord.y / u_sheight);\n"
"float depth = texture(u_depth0, screen_to_coord).r;\n"
"\n"
"//o_color = vec4(vec3(1.0/depth), 1.0);\n"
"//return;\n"
"\n"
"if (depth != v_depth || v_coords3.z > -20.0) discard;\n"
"\n"
"\n"
"\n"
"\n"
"////////////////////////////\n"
"// calculate dither\n"
"\n"
"ivec2 index = ivec2(mod(gl_FragCoord.xy, vec2(4.0)));\n"
"int k = int(u_dithermat[index.x][index.y]);\n"
"\n"
"\n"
"/*\n"
"////////////////////////////\n"
"// calculate final color value\n"
"\n"
"//vec4 color = norm_to_color(normalize(T));\n"
"//vec4 color = norm_to_color(norm);\n"
"vec4 color = v_color * tex_color;\n"
"//color = vec4((color.rgb * (diffuse + backlight) * u_light_bright +\n"
"color = vec4(color.rgb * (diffuse + ambient) + specular, color.a);\n"
"\n"
"//color = vec4(vec3(depth*10.0), 1.0);\n"
"//o_color = clamp(vec4(color.rgb/2.0, color.a), 0.0, 1.0);\n"
"//return;*/\n"
"\n"
"//float colormul = (depth/1.88/2.0 <= float(k)) ? (1.0) : (1.0);\n"
"//float alphamul = (depth/1.88/2.0 <= float(k)) ? (0.5) : (1.0);\n"
"\n"
"//if (depth != v_depth && v_coords3.z < -20.0) discard;\n"
"//if (depth != v_depth || v_coords3.z > -20.0) discard;\n"
"\n"
"//if (depth != v_depth || (v_coords3.z > -20.0 && u_mode == 1)) discard;\n"
"//if (depth != v_depth && u_mode == 1) discard;\n"
"\n"
"/*if (v_depth > depth) {\n"
"o_color = vec4(1.0,0.0,1.0,1.0);\n"
"return;\n"
"}*/\n"
"\n"
"//o_color = vec4(vec3(1.0/(depth-v_depth)), 1.0);\n"
"//o_color = vec4(vec3(depth!=v_depth), 1.0);\n"
"//o_color = vec4(vec3(10.0/v_depth), 1.0);\n"
"//o_color = vec4(vec3(v_coords3.z > -20.0 - 0.01 ? 1.0 : 0.0), 1.0);\n"
"//return;\n"
"\n"
"//return;\n"
"\n"
"vec3 colormul = vec3(1.0);\n"
"float alphamul = 1.0;\n"
"float kmul = 0.5;\n"
"\n"
"\n"
"/*if (v_coords3.z > -20.0) {\n"
"//alphamul /= 2.0;\n"
"kmul /= 2.0;\n"
"}*/\n"
"\n"
"/*if (v_coords3.z > -20.0 - 0.01) {\n"
"depth = v_depth;\n"
"}*/\n"
"\n"
"/*if (u_mode == 0)\n"
"colormul = vec3(8.0, 8.0, 4.0);*/\n"
"\n"
"if (v_depth/1.88/2.0 <= float(k))\n"
"/*if (u_mode == 0) {\n"
"alphamul /= 2.0;\n"
"} else {\n"
"alphamul /= 2.0;\n"
"}*/\n"
"if (u_mode == 0)\n"
"alphamul = 0.75;\n"
"else\n"
"alphamul /= 2.0;\n"
"else\n"
";\n"
"\n"
"\n"
"/*if (depth/1.88/2.0 <= float(k))\n"
"//if (sqrt(sqrt(depth))/1.88*6.0*2.0 <= float(k))\n"
"o_color = clamp(vec4(u_fog_color.rgb, u_fog_color.a/2.0), 0.0, 1.0);\n"
"//discard;\n"
"else\n"
"o_color = clamp(vec4(u_fog_color.rgb, u_fog_color.a), 0.0, 1.0);*/\n"
"\n"
"o_color = clamp(vec4(u_fog_color.rgb*colormul, u_fog_color.a*alphamul), 0.0, 1.0);\n"
"//gl_FragDepth = 0.0;\n"
"\n"
"//o_color = vec4(1.0);\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"vec3 color_to_norm(vec4 color) {\n"
"vec3 norm = normalize(color.rgb * 2.0 - 1.0);\n"
"return vec3(norm.x, norm.y, norm.z);\n"
"//return vec3(norm.x, norm.y, norm.z);\n"
"}\n"
"\n"
"\n"
"vec4 norm_to_color(vec3 norm) {\n"
"vec3 _norm = vec3(norm.x, norm.y, norm.z);\n"
"return vec4(clamp((_norm + 1.0) / 2.0, 0.0, 1.0), 1.0);\n"
"//return vec4(clamp((norm + 1.0) / 2.0, 0.0, 1.0), 1.0);\n"
"}\n"
"\n"
"/*vec2 vfloor(vec2 n) {\n"
"return vec2(floor(n.x), floor(n.y));\n"
"}*/\n"
"\n"
"\n"
"/*vec4 encode_float_to_color(float value) {\n"
"uint bits = floatBitsToUint(value);\n"
"\n"
"float b0 = float((bits >> 0)  & 0xFF);\n"
"float b1 = float((bits >> 8)  & 0xFF);\n"
"float b2 = float((bits >> 16) & 0xFF);\n"
"float b3 = float((bits >> 24) & 0xFF);\n"
"\n"
"return vec4(b0, b1, b2, b3) / 256.0;\n"
"}\n"
"\n"
"\n"
"float decode_color_to_float(vec4 color) {\n"
"uint b0 = uint(color[0] * 256.0);\n"
"uint b1 = uint(color[1] * 256.0);\n"
"uint b2 = uint(color[2] * 256.0);\n"
"uint b3 = uint(color[3] * 256.0);\n"
"\n"
"uint bits = (b0<<0) | (b1<<8) | (b2<<16) | (b3<<24);\n"
"\n"
"return uintBitsToFloat(bits);\n"
"}*/\n"
"\n"
"\n"
"\n"
"float monochrome(vec4 color) {\n"
"return (color.r*0.299 + color.g*0.587 + color.b*0.114) * color.a;\n"
"}\n"
"\n"
"\n"
"float monochrome(vec3 color) {\n"
"return color.r*0.299 + color.g*0.587 + color.b*0.114;\n"
"}\n"
;
